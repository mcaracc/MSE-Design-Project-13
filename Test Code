#include <Servo.h>
#include <EEPROM.h>
#include <uSTimer2.h>
#include <CharliePlexM.h>
#include <Wire.h>
#include <I2CEncoder.h>
#include <StackArray.h>
#include "NewPing.h"
#include <SoftwareSerial.h>

Servo servo_RightMotor;
Servo servo_LeftMotor;
Servo servo_SweeperMotor;
Servo servo_ScooperMotor;

I2CEncoder encoder_RightMotor;
I2CEncoder encoder_LeftMotor;

class Movement
{
  public:
    int move;
    unsigned long time;
};
  StackArray <Movement> stack;
  int stackSize;
 
 SoftwareSerial mySerial(2, 13); // RX, TX
 
// Uncomment keywords to enable debugging output
  //#define DEBUG_MODE_DISPLAY
  //#define DEBUG_MOTORS
  //#define DEBUG_ENCODERS
  //#define DEBUG_ULTRASONIC
  //#define DEBUG_LINE_TRACKER_CALIBRATION
  //#define DEBUG_MOTOR_CALIBRATION

boolean bt_Motors_Enabled = true;
#define Ultrasonic_Ping1  A0
#define Ultrasonic_Data1  A0
#define Ultrasonic_Ping2  A1
#define Ultrasonic_Data2  A1
#define Ultrasonic_Ping3  A2
#define Ultrasonic_Data3  A2
#define Ultrasonic_Ping4  A3 //backward facing sensor
#define Ultrasonic_Data4  A3
#define MAX_DISTANCE 400

NewPing sonar1(Ultrasonic_Ping1, Ultrasonic_Data1, MAX_DISTANCE);
NewPing sonar2(Ultrasonic_Ping2, Ultrasonic_Data2, MAX_DISTANCE);
NewPing sonar3(Ultrasonic_Ping3, Ultrasonic_Data3, MAX_DISTANCE);
NewPing sonar4(Ultrasonic_Ping4, Ultrasonic_Data4, MAX_DISTANCE); //for backward facing ul sensor

float echo1; // Stores calculated distance in cm for First Sensor
float echo2; // Stores calculated distance in cm for Second Sensor
float echo3; // Stores calculated distance in cm for Third Sensor
float echo4; // Stores calculated distance in cm for Fourth Sensor
float soundsp;  // Stores calculated speed of sound in M/S
float soundcm;  // Stores calculated speed of sound in cm/ms
int iterations = 2;

//port pin constants
//const int Ultrasonic_Ping1 = A0;   //input plug
//const int Ultrasonic_Data1 = A0;   //output plug
const int ci_Light_Sensor = 2;
//const int (insert motor / sensor here) = 3;
const int ci_Charlieplex_LED1 = 4;
const int ci_Charlieplex_LED2 = 5;
const int ci_Charlieplex_LED3 = 6;
const int ci_Charlieplex_LED4 = 7;
const int ci_Mode_Button = 7;
const int ci_Right_Motor = 8;
const int ci_Left_Motor = 9;
const int ci_Scooper_Motor = 10;
const int ci_Sweeper_Motor = 11; 
const int ci_Motor_Enable_Switch = 12;
//const int (insert motor / sensor here) = 13;
//const int Ultrasonic_Ping2 = A1; //input plug
//const int Ultrasonic_Data2 = A1; //output plug
//const int Ultrasonic_Ping3 = A2; //input plug
//const int Ultrasonic_Data3 = A2; //output plug
//const int Ultrasonic_Ping4 = A3;
const int ci_I2C_SDA = A4;         // I2C data = white
const int ci_I2C_SCL = A5;         // I2C clock = yellow

unsigned long ultrasonic1;
unsigned long ultrasonic2;
unsigned long ultrasonic3;
unsigned long ultrasonic4;

const int Motor_Stop = 1500;        // 200 for brake mode; 1500 for stop
//const int Motor_Brake = 200;
//const int ci_Scooper_Motor_Up = 160;
const int ci_Scooper_Motor_Down = 65;

const int ul_front_D = 25;
const int ul_side_D = 26;

//variables
//unsigned int ui_Motors_Speed = 1900;        // Default run speed
unsigned int ui_Left_Motor_Speed;
unsigned int ui_Right_Motor_Speed;

unsigned long ul_3_Second_timer = 0;

unsigned int ui_Cal_Cycle;

unsigned int  ui_Robot_State_Index = 0;
//0123456789ABCDEF
unsigned int  ui_Mode_Indicator[6] = {
  0x00,    //B0000000000000000,  //Stop
  0x00FF,  //B0000000011111111,  //Run
  0x0F0F,  //B0000111100001111,  //Calibrate line tracker light level
  0x3333,  //B0011001100110011,  //Calibrate line tracker dark level
  0xAAAA,  //B1010101010101010,  //Calibrate motors
  0xFFFF   //B1111111111111111   //Unused
};

unsigned int  ui_Mode_Indicator_Index = 0;

//display Bits 0,1,2,3, 4, 5, 6,  7,  8,  9,  10,  11,  12,  13,   14,   15
int  iArray[16] = {
  1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,65536};
int  iArrayIndex = 0;

boolean bt_Heartbeat = true;
boolean bt_3_S_Time_Up = false;
boolean bt_Do_Once = false;
boolean bt_Cal_Initialized = false;

//flags
  bool flag_1 = true; 
  bool flag_2A = true; 
  bool flag_3A = true; 
  bool flag_4A = true;
  bool flag_5A = true;
  bool flag_6A = true;
  bool flag_7A = true;
  bool flag_8A = true;
  bool case_B = false;
  bool case_C = false;
  
  bool A = true;
  bool B = true;
  bool C = true;

  bool flag_2B_reversed = false;
  bool flag_2C_reversed = true;
  bool flag_3B_reversed = false;
  bool flag_3C_reversed = true;
  bool flag_4B_reversed = false;
  bool flag_4C_reversed = true;
  bool flag_5B_reversed = false;
  bool flag_5C_reversed = true;
  bool flag_6B_reversed = false;
  bool flag_6C_reversed = true;
  bool flag_7B_reversed = false;
  bool flag_7C_reversed = true;
  bool flag_8B_reversed = false;
  bool flag_8C_reversed = true;

  bool Stack1 = true;
  bool Stack2 = false;
  bool Stack3 = false;

  bool x = true;

long currentMove, currentTime;
unsigned long currentMillis;
unsigned long startVal;
unsigned long startTime, endTime;
unsigned long newStartTime, newEndTime;


void setup() 
{
  Wire.begin();// Wire library required for I2CEncoder library
  Serial.begin(9600);

  CharliePlexM::setBtn(ci_Charlieplex_LED1,ci_Charlieplex_LED2,ci_Charlieplex_LED3,ci_Charlieplex_LED4,ci_Mode_Button);

  // set up drive motors
    pinMode(ci_Right_Motor, OUTPUT);
    servo_RightMotor.attach(ci_Right_Motor);
    pinMode(ci_Left_Motor, OUTPUT);
    servo_LeftMotor.attach(ci_Left_Motor);
  // set up scooper motor
    pinMode(ci_Scooper_Motor, OUTPUT);
    servo_ScooperMotor.attach(ci_Scooper_Motor);

  // set up encoders. Must be initialized in order that they are chained together, 
  // starting with the encoder directly connected to the Arduino
    encoder_LeftMotor.init(1.0/3.0*MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);
    encoder_LeftMotor.setReversed(false);  // adjust for positive count when moving forward
    encoder_RightMotor.init(1.0/3.0*MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);  
    encoder_RightMotor.setReversed(true);  // adjust for positive count when moving forward

}

void loop()
{
  //3 seconds timer flag
  if((millis() - ul_3_Second_timer) > 3000)
  {
    bt_3_S_Time_Up = true;
  }

  // button-based mode selection
  if(CharliePlexM::ui_Btn)
  {
    if(bt_Do_Once == false)
    {
      bt_Do_Once = true;
      ui_Robot_State_Index++;
      ui_Robot_State_Index = ui_Robot_State_Index & 7;
      ul_3_Second_timer = millis();
      bt_3_S_Time_Up = false;
      bt_Cal_Initialized = false;
      ui_Cal_Cycle = 0;
    }
  }
  else
  {
    bt_Do_Once = LOW;
  }

  // check if drive motors should be powered
  bt_Motors_Enabled = digitalRead(ci_Motor_Enable_Switch);

  // modes 
  // 0 = default after power up/reset
  // 1 = Press mode button once to enter. Run robot.
  // 2 = Press mode button twice to enter. Calibrate line tracker light level.
  // 3 = Press mode button three times to enter. Calibrate line tracker dark level.
  // 4 = Press mode button four times to enter. Calibrate motor speeds to drive straight.
  
  switch(ui_Robot_State_Index)
  {
    case 0: //Robot stopped
    {
      Serial.println("nothing...");
      Ping();
      servo_LeftMotor.writeMicroseconds(Motor_Stop); 
      servo_RightMotor.writeMicroseconds(Motor_Stop);
      Serial.print(" Ultrasonic 1: ");
      Serial.println(ultrasonic1 );
      Serial.print(" Ultrasonic 2: ");
      Serial.println(ultrasonic2 );
      Serial.print(" Ultrasonic 3: ");
      Serial.println(ultrasonic3 );
      
      ui_Mode_Indicator_Index = 0;
      break;
    } 
  
    case 1:  //Robot Run after 3 seconds
    {
      Serial.print("Stack size: ");
      Serial.println(stackSize);
      if ( Stack1 == true)
      {
        Serial.println("Phase 1...");
      }
      else if ( Stack2 == true)
      {
        Serial.println("Phase 2...");
      }
      else if ( Stack3 == true)
      {
        Serial.println("Phase 3...");
      }
      if ( stackSize > 2 && Stack1 == true)
      { 
        Serial.println("Phase 2 starting...");
        Stack1 = false;
        Stack2 = true;
      }
      if ( stackSize == 1 && Stack1 == false && Stack2 == true)
      {
        Serial.println("Phase 3 starting...");
        Stack2 == false;
        Stack3 == true;
      }      
      if ( stackSize == 0 && Stack1 == false && Stack2 == false && Stack3 == true)
      {
        Serial.println("resetting Phase 1...");
        Stack3 == false;
        Stack1 == true;
      }
      
      if (x == true)
      {
         Ping();
        if(bt_3_S_Time_Up)
        {
          if ( (ultrasonic1 > ul_front_D) && A == true) // go foward if nothing is at front
          {
            Serial.println("going forward...");
            if (flag_1 == true)
            {
              startTime = millis(); // start time
              flag_1 = false;
            }
            servo_RightMotor.writeMicroseconds(1800); // go forward
            servo_LeftMotor.writeMicroseconds(1800);
          }
          else if ( (ultrasonic1 > 1) && (ultrasonic1 < ul_front_D) && A == true )
          {
            Serial.println("stopping...");
            servo_RightMotor.writeMicroseconds(1500); // stop
            servo_LeftMotor.writeMicroseconds(1500);
            endTime = millis(); // end time
            currentTime = endTime - startTime;
            Serial.print("time: ");
            Serial.println(currentTime);
            A = false;
          }
          if (A == false && B == true)
          {
            newStartTime = millis();
            if (C == true)
            {
              newEndTime = newStartTime + currentTime;
              C = false;
            }
            if (newStartTime < newEndTime)
            {
              Serial.println("backing up...");
              servo_RightMotor.writeMicroseconds(1200); // go backward
              servo_LeftMotor.writeMicroseconds(1200);
            }
            else
            {
              Serial.println("done backing up...");
              servo_RightMotor.writeMicroseconds(1500); //stop
              servo_LeftMotor.writeMicroseconds(1500); 
              B = false;
            } 
        }
        if (A == false && B == false)
        {
          Serial.println("dumping...");
          Serial.println("going up...");
          //servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Up);
          delay(2000);
          Serial.println("going down...");
          //servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
          Serial.println("hard code done");
          x = false;
          flag_1 = true; 
        } 
       } 
      }
      if (x == false)
       {
        if (Stack1 == true)
        {
            Ping();
            Infrared();
            Serial.print(" Ultrasonic 1: ");
            Serial.println(ultrasonic1);
            Serial.print(" Ultrasonic 2: ");
            Serial.println(ultrasonic2);
            Serial.print(" Ultrasonic 3: ");
            Serial.println(ultrasonic3);
              
            if ( ((ultrasonic1) > ul_front_D) && ((ultrasonic2) > ul_side_D) && ((ultrasonic3) > ul_side_D) && flag_1 == true) //Case 1: no objects nearby, drive straight 
            {
              //servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              if (A == true)
              {
                startTime = millis();
                A = false;
                Serial.print("startTime: ");
                Serial.println(startTime);
              }
              Serial.print('\n');
              Serial.println("case1");
    
              servo_RightMotor.writeMicroseconds(1600);
              servo_LeftMotor.writeMicroseconds(1600); 
            }
            
            else if ( ((ultrasonic1) <= ul_front_D && (ultrasonic1) > 1)  && ((ultrasonic2) <= ul_side_D) && ((ultrasonic2) > 1) && ((ultrasonic3) <= ul_side_D) && ((ultrasonic3) > 1) && flag_2A == true) //Case 2: object in front, AND object on left, AND object on right. back up turn 180deg
            {
              servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              Serial.println("case2A");
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize); 
           
                A = true;
                Serial.println("saved");
              } 
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;
            
              case_B = true;    
            }
              if (case_B == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(case_C == true) // start timer
                  {
                    startVal = currentMillis;
                    case_C = false;
                  }
                  if (case_C == false)
                  {
                      if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                      {
                        servo_RightMotor.writeMicroseconds(1400);
                        servo_LeftMotor.writeMicroseconds(1400);
                        Serial.println("case2B");
                      }
                      else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 1200)//turn 180
                      {
                        servo_RightMotor.writeMicroseconds(1700);
                        servo_LeftMotor.writeMicroseconds(1300);
                        Serial.println("case2C");
                      }
                      else if((currentMillis-startVal) > 1200)
                      {
                        flag_1 = true; 
                        flag_2A = true;
                        flag_3A = true;
                        flag_4A = true;
                        flag_5A = true;
                        flag_6A = true;
                        flag_7A = true;
                        flag_8A = true;
    
                        case_B = false;
                        case_C = true;
  
                        Movement T;
                        T.move = 2;
                        T.time = 1200;
                        stack.push(T);
                        stackSize = stack.count();
                        Serial.print("Stack size: ");
                        Serial.println(stackSize); 
                      }
                  }
               }
    
     else if ( ((ultrasonic1) <= ul_front_D && (ultrasonic1) > 1)  && (ultrasonic2 > ul_side_D) && (ultrasonic3 > ul_side_D) && flag_3A == true) //Case 3: object in front, no object on left, no object on right. back up, turn left (can be right too)
            {
              servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              Serial.println("case3A");
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize);  
                A = true;
                Serial.println("saved");
              } 
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;
    
              
              case_B = true; 
            }
              if (case_B == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(case_C == true) // start timer
                  {
                    startVal = currentMillis;
                    case_C = false;
                  }
                  if (case_C == false)
                  {
                      if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                      {
                        servo_RightMotor.writeMicroseconds(1400);
                        servo_LeftMotor.writeMicroseconds(1400);
                        Serial.println("case3B");
                      }
                      else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 1000)//turn left 225deg
                      {
                        servo_RightMotor.writeMicroseconds(1700);
                        servo_LeftMotor.writeMicroseconds(1300); 
                        Serial.println("case3C");
                      }
                      else if((currentMillis-startVal) > 1000)
                      {
                        flag_1 = true; 
                        flag_2A = true;
                        
                        flag_3A = true;
                        flag_4A = true;
                        flag_5A = true;
                        flag_6A = true;
                        flag_7A = true;
                        flag_8A = true;
                        
                        case_B = false;
                        case_C = true;
  
                        Movement T;
                        T.move = 3;
                        T.time = 1000;
                        stack.push(T);
                        stackSize = stack.count();
                        Serial.print("Stack size: ");
                        Serial.println(stackSize); 
                      }
                  }
               }
               
     else if ( (ultrasonic1 > ul_front_D) && (ultrasonic2 > ul_side_D) && ((ultrasonic3) <= ul_side_D) && ((ultrasonic3) > 1) && flag_4A == true) //Case 4: NO object in front, no object on left, AND object on right, turn left 90deg
            {
              servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              Serial.println("case4A"); 
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize); 
                A = true;
                Serial.println("saved");
              }  
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;
              
              case_B = true; 
            }
              if (case_B == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(case_C == true) // start timer
                  {
                    startVal = currentMillis;
                    case_C = false;
                  }
                  if (case_C == false)
                  {
                      if((currentMillis-startVal) < 400) //turn left 90deg
                      {
                        servo_RightMotor.writeMicroseconds(1700);
                        servo_LeftMotor.writeMicroseconds(1300);
                        Serial.println("case4B");
                      }
                      else if((currentMillis-startVal) > 400)
                      {
                        flag_1 = true; 
                        flag_2A = true;
                        flag_3A = true;
                        flag_4A = true;
                        flag_5A = true;
                        flag_6A = true;
                        flag_7A = true;
                        flag_8A = true;
                        
                        case_B = false;
                        case_C = true;
  
                        Movement T;
                        T.move = 4;
                        T.time = 400;
                        stack.push(T);
                        stackSize = stack.count();
                        Serial.print("Stack size: ");
                        Serial.println(stackSize); 
                      }
                  }
               }
    
     if ( (ultrasonic1 > ul_front_D) && ((ultrasonic2) <= ul_side_D) && ((ultrasonic2) > 1) && (ultrasonic3 > ul_side_D) && flag_5A == true) //Case 5: NO object in front, AND object on left, no object on right, turn right 90deg
            {
              servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              Serial.println("case5A");
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize); 
                A = true;
                Serial.println("saved");
              }  
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;
              
              case_B = true; 
            }
              if (case_B == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.print (currentMillis);
                //Serial.print('\n')
                  if(case_C == true) // start timer
                  {
                    startVal = currentMillis;
                    case_C = false;
                  }
                  if (case_C == false)
                  {
                      if((currentMillis-startVal) < 400) //turn right 90deg
                      {
                        servo_RightMotor.writeMicroseconds(1300);
                        servo_LeftMotor.writeMicroseconds(1700);
                        Serial.println("case5B");
                      }
                      else if((currentMillis-startVal) > 400)
                      {
                        flag_1 = true; 
                        flag_2A = true;
                        flag_3A = true;
                        flag_4A = true;
                        flag_5A = true;
                        flag_6A = true;
                        flag_7A = true;
                        flag_8A = true;
                        
                        case_B = false;
                        case_C = true;
  
                        Movement T;
                        T.move = 5;
                        T.time = 400;
                        stack.push(T);
                        stackSize = stack.count();
                        Serial.print("Stack size: ");
                        Serial.println(stackSize); 
                      }
                  }
               }
    
    else if ( ((ultrasonic1) <= ul_front_D && (ultrasonic1) > 1)  && ((ultrasonic2) <= ul_side_D) && ((ultrasonic2) > 1) && ((ultrasonic3) > ul_side_D) && flag_6A == true) //Case 6: object in front, AND object on left, no object on right. back up turn right 90deg
            {
              servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              Serial.println("case6A");
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize);  
                A = true;
                Serial.println("saved");
              }  
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;
              
              case_B = true; 
            }
              if (case_B == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(case_C == true) // start timer
                  {
                    startVal = currentMillis;
                    case_C = false;
                  }
                  if (case_C == false)
                  {
                      if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                      {
                        servo_RightMotor.writeMicroseconds(1400);
                        servo_LeftMotor.writeMicroseconds(1400);
                        Serial.println("case6B");
                      }
                      else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 800)//turn right
                      {
                        servo_RightMotor.writeMicroseconds(1300);
                        servo_LeftMotor.writeMicroseconds(1700);
                        Serial.println("case6C");
                      }
                      else if((currentMillis-startVal) > 800)
                      {
                        flag_1 = true; 
                        flag_2A = true;
                        flag_3A = true;
                        flag_4A = true;
                        flag_5A = true;
                        flag_6A = true;
                        flag_7A = true;
                        flag_8A = true;
                        
                        case_B = false;
                        case_C = true;
  
                        Movement T;
                        T.move = 6;
                        T.time = 800;
                        stack.push(T);
                        stackSize = stack.count();
                        Serial.print("Stack size: ");
                        Serial.println(stackSize); 
                      }
                  }
               }
    
         else if ( ((ultrasonic1) <= ul_front_D && (ultrasonic1) > 1) && ((ultrasonic2 ) > ul_side_D) && ((ultrasonic3 ) <= ul_side_D) && ((ultrasonic3 ) > 1) && flag_7A == true) //Case 7: object in front, no object on left, AND object on right. back up turn left 90deg
            {
              servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              Serial.println("case7A");
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize);  
                A = true;
                Serial.println("saved");
              }  
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;
              
              case_B = true; 
            }
              if (case_B == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(case_C == true) // start timer
                  {
                    startVal = currentMillis;
                    case_C = false;
                  }
                  if (case_C == false)
                  {
                      if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                      {
                        servo_RightMotor.writeMicroseconds(1400);
                        servo_LeftMotor.writeMicroseconds(1400);
                        Serial.println("case7B");
                      }
                      else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 800)//turn left
                      {
                        servo_RightMotor.writeMicroseconds(1700);
                        servo_LeftMotor.writeMicroseconds(1300);
                        Serial.println("case7C");
                      }
                      else if((currentMillis-startVal) > 800)
                      {
                        flag_1 = true; 
                        flag_2A = true;
                        flag_3A = true;
                        flag_4A = true;
                        flag_5A = true;
                        flag_6A = true;
                        flag_7A = true;
                        flag_8A = true;
                        
                        case_B = false;
                        case_C = true;
  
                        Movement T;
                        T.move = 7;
                        T.time = 800;
                        stack.push(T);
                        stackSize = stack.count();
                        Serial.print("Stack size: ");
                        Serial.println(stackSize); 
                      }
                  }
               }
    
      else if ( ((ultrasonic1 ) > ul_front_D) && ((ultrasonic2 ) <= ul_side_D && (ultrasonic2) > 1)  && (((ultrasonic3) <= ul_side_D) && (ultrasonic3) > 1) && flag_8A == true) //Case 8: no object in front, AND object on left, AND object on right. straight
            {
              servo_ScooperMotor.writeMicroseconds(ci_Scooper_Motor_Down);
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              Serial.println("case8A");
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize);  
                A = true;
                Serial.println("saved");
              } 
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;
            
              case_B = true;    
            }
              if (case_B == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(case_C == true) // start timer
                  {
                    startVal = currentMillis;
                    case_C = false;
                  }
                  if (case_C == false)
                  {
                      if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                      {
                        servo_RightMotor.writeMicroseconds(1400);
                        servo_LeftMotor.writeMicroseconds(1400);
                        Serial.println("case8B");
                      }
                      else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 1200)//turn 180
                      {
                        servo_RightMotor.writeMicroseconds(1700);
                        servo_LeftMotor.writeMicroseconds(1300);
                        Serial.println("case8C");
                      }
                      else if((currentMillis-startVal) > 1200)
                      {
                        flag_1 = true; 
                        flag_2A = true;
                        flag_3A = true;
                        flag_4A = true;
                        flag_5A = true;
                        flag_6A = true;
                        flag_7A = true;
                        flag_8A = true;
    
                        case_B = false;
                        case_C = true;
  
                        Movement T;
                        T.move = 8;
                        T.time = 1200;
                        stack.push(T);
                        stackSize = stack.count();
                        Serial.print("Stack size: ");
                        Serial.println(stackSize); 
                      }
                  }
               }
          }  
        else if (Stack2 == true) //begin first return home 
        {
          // save case 1 if its running while timer ends
          if (A == false)
              {
                endTime = millis();
                Serial.print("endTime: ");
                Serial.println(endTime);
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                Serial.print("Stack size: ");
                Serial.println(stackSize); 
                A = true;
                Serial.println("saved");
              } 
          
          Serial.println("transverse");
          // flag to check if stack is empty: 0 = full, 1 = empty
          bool stack_empty;
          if (stackSize > 1)
          {
            stack_empty = false;
          }
          else if (stackSize = 1)
          {
            stack_empty = true;
          }
          Serial.print("size: ");
          Serial.println(stackSize);
          Serial.print("stack flag: ");
          Serial.println(stack_empty);
          
  
            if (B == true && stack_empty == false)
            {
              Serial.println("saving Move");
              Movement lastMove;
              lastMove = stack.pop();
              stackSize = stack.count();
              Serial.print("Stack size: ");
              Serial.println(stackSize); 
              currentMove = lastMove.move;
              currentTime = lastMove.time;
              Serial.print("currentMove: ");
              Serial.println(currentMove);
              Serial.print("currentTime: ");
              Serial.println(currentTime);
              B = false;
              C = true;  
            }
            if (B == false && stack_empty == false)
            {
              if (currentMove == 1 && B == false)
              {
                Serial.println("Starting to reverse case1");
                newStartTime = millis();
                Serial.print("newStartTime: ");
                Serial.println(newStartTime);
                if (C == true)
                {
                  newEndTime = newStartTime + currentTime;
                  Serial.print("newEndTime: ");
                  Serial.println(newEndTime);
                  C = false;
                }
                if ( newStartTime < newEndTime )
                {
                   Serial.print("newStartTime2: ");
                   Serial.println(newStartTime);
                   Serial.print("newEndTime2: ");
                   Serial.println(newEndTime);
                   Serial.println("backing up...");
                   servo_RightMotor.writeMicroseconds(1400);
                   servo_LeftMotor.writeMicroseconds(1400);
                 }
                 else
                 {
                    Serial.println("Stopping1...");
                   servo_RightMotor.writeMicroseconds(1500);
                   servo_LeftMotor.writeMicroseconds(1500);
                   B = true;
                 }
              } 
              if (currentMove == 2 && B == false)
              { 
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);
                
                flag_2B_reversed = true; 
               if (flag_2B_reversed == true) 
              {
                currentMillis = millis();
                  if(flag_2C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_2C_reversed = false;
                  }
                  if (flag_2C_reversed == false)
                  {
                      if((currentMillis-startVal) < 800) //turn 180
                      {
                        servo_RightMotor.writeMicroseconds(1300);
                        servo_LeftMotor.writeMicroseconds(1700);
                        Serial.println("case2C reversed");
                        
                      }
                      else if((currentMillis-startVal)> 800 && (currentMillis-startVal) < 1200)//go forward slightly
                      {
                        servo_RightMotor.writeMicroseconds(1600);
                        servo_LeftMotor.writeMicroseconds(1600);
                        Serial.println("case2B reversed");
                      }
                      else if((currentMillis-startVal) > 1200)
                      {
                        flag_2B_reversed = false;
                        flag_2C_reversed = true;
                        B = true;
                      }
                     }
                   }
                  } 
               if (currentMove == 3 && B == false)
            {
               servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);
                
                flag_3B_reversed = true; 
            
               if (flag_3B_reversed == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(flag_3C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_3C_reversed = false;
                  }
                  if (flag_3C_reversed == false)
                  {
                      if((currentMillis-startVal) < 600) //turn right .6 seconds
                      {
                        servo_RightMotor.writeMicroseconds(1300);
                        servo_LeftMotor.writeMicroseconds(1700);
                        Serial.println("case3B");
                      }
                      else if((currentMillis-startVal)> 600 && (currentMillis-startVal) < 1000)//drive straight .4 seconds
                      {
                        servo_RightMotor.writeMicroseconds(1600);
                        servo_LeftMotor.writeMicroseconds(1600); 
                        Serial.println("case3C");
                      }
                      else if((currentMillis-startVal) > 1000)
                      {
                        flag_3B_reversed = false;
                        flag_3C_reversed = true;
                        B = true;
                      }
                  }
              }    
            }
              if (currentMove == 4 && B == false)
              {
             servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
             servo_RightMotor.writeMicroseconds(Motor_Stop);
              
              flag_4B_reversed = true; 
            
              if (flag_4B_reversed == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(flag_4C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_4C_reversed = false;
                  }
                  if (flag_4C_reversed == false)
                  {
                      if((currentMillis-startVal) < 400) //turn right 90deg
                      {
                        Serial.print("time: ");
                        Serial.println(currentMillis-startVal);
                        servo_RightMotor.writeMicroseconds(1300);
                        servo_LeftMotor.writeMicroseconds(1700);
                        Serial.println("case4B_reversed");
                      }
                      else if((currentMillis-startVal) > 400)
                      {
                        flag_4B_reversed = false;
                        flag_4C_reversed = true;
                        B = true;
                      }
                  }
               }
             }
             if (currentMove == 5 && B == false)
             {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_5B_reversed = true;
              if (flag_5B_reversed == true)
              {
                currentMillis = millis();
                Serial.print ("Millis: ");
                Serial.println(currentMillis);
                  if(flag_5C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_5C_reversed = false;
                  }
                  if (flag_5C_reversed == false)
                  {
                      if((currentMillis-startVal) < 400) //turn left 90deg
                      {
                        Serial.print("time: ");
                        Serial.println(currentMillis-startVal);
                        servo_RightMotor.writeMicroseconds(1700);
                        servo_LeftMotor.writeMicroseconds(1300);
                        Serial.println("case5B_reversed");
                      }
                      else if((currentMillis-startVal) > 400)
                      {
                        flag_5B_reversed = false;
                        flag_5C_reversed = true;
                        B = true;
                      }
                  }
               }
             }
             if (currentMove == 6 && B == false)
             {
             servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
             servo_RightMotor.writeMicroseconds(Motor_Stop);
              
              flag_6B_reversed = true; 
            
              if (flag_6B_reversed == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(flag_6C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_6C_reversed = false;
                  }
                  if (flag_6C_reversed == false)
                  {
                       if((currentMillis-startVal) < 400) //turn left 90deg
                      {
                        servo_RightMotor.writeMicroseconds(1700);
                        servo_LeftMotor.writeMicroseconds(1300);
                        Serial.println("case6B_reversed");
                      }
                      else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 800) //drive stright 0.4s
                      {
                        servo_RightMotor.writeMicroseconds(1600);
                        servo_LeftMotor.writeMicroseconds(1600);
                        Serial.println("case6C_reversed");
                      }
                      else if((currentMillis-startVal) > 800)
                      {
                        flag_6B_reversed = false;
                        flag_6C_reversed = true;
                        B = true;
                      }
                  }
               }
             }
               if (currentMove == 7 && B == false)
              {
             servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
             servo_RightMotor.writeMicroseconds(Motor_Stop);
              
              flag_7B_reversed = true; 
            
              if (flag_7B_reversed == true)
              {
                currentMillis = millis();
                //Serial.print ("Millis: ");
                //Serial.println(currentMillis);
                  if(flag_6C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_7C_reversed = false;
                  }
                  if (flag_7C_reversed == false)
                  {
                       if((currentMillis-startVal) < 400) //turn right 90deg
                      {
                        servo_RightMotor.writeMicroseconds(1300);
                        servo_LeftMotor.writeMicroseconds(1700);
                        Serial.println("case7B_reversed");
                      }
                      else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 800) //drive stright 0.4s
                      {
                        servo_RightMotor.writeMicroseconds(1600);
                        servo_LeftMotor.writeMicroseconds(1600);
                        Serial.println("case7C_reversed");
                      }
                      else if((currentMillis-startVal) > 800)
                      {
                        flag_7B_reversed = false;
                        flag_7C_reversed = true;
                        B = true;
                      }
                  }
               }
             }
            if (currentMove == 8 && B == false)
              { 
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);
                
                flag_8B_reversed = true; 
               if (flag_8B_reversed == true) 
              {
                currentMillis = millis();
                  if(flag_8C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_8C_reversed = false;
                  }
                  if (flag_8C_reversed == false)
                  {
                      if((currentMillis-startVal) < 800) //turn 180
                      {
                        servo_RightMotor.writeMicroseconds(1300);
                        servo_LeftMotor.writeMicroseconds(1700);
                        Serial.println("case8C reversed");
                        
                      }
                      else if((currentMillis-startVal)> 800 && (currentMillis-startVal) < 1200)//go forward slightly
                      {
                        servo_RightMotor.writeMicroseconds(1600);
                        servo_LeftMotor.writeMicroseconds(1600);
                        Serial.println("case8B reversed");
                      }
                      else if((currentMillis-startVal) > 1200)
                      {
                        flag_8B_reversed = false;
                        flag_8C_reversed = true;
                        B = true;
                      }
                     }
                   }
                  } 
           }
           if (stack_empty == true)
            {
              Serial.println("Stopping2...");
                servo_RightMotor.writeMicroseconds(1500);
                servo_LeftMotor.writeMicroseconds(1500);
                break;
            }
        }
        else if (Stack3 == true)
        {
          
        }
      }
        ui_Mode_Indicator_Index = 1;
        break;
      } 
    case 2:
    {
      
      
      break;
    } 
  }
} 



// measure distance to target using ultrasonic sensor  
void Ping()
{
 soundsp = 331.4; // Calculate the Speed of Sound in M/S
 soundcm = soundsp / 10000;  // Convert to cm/ms
 
 echo1 = sonar1.ping_median(iterations); // Measure duration for first sensor (front)
 echo2 = sonar2.ping_median(iterations); // Measure duration for second sensor (left)
 echo3 = sonar3.ping_median(iterations); // Measure duration for third sensor (right)
 echo4 = sonar4.ping_median(iterations); // Measure duration for fourth sensor (back)
 
 
 // Calculate the distances for three sensors
 ultrasonic1 = (echo1 / 2) * soundcm;
 ultrasonic2 = (echo2 / 2) * soundcm;
 ultrasonic3 = (echo3 / 2) * soundcm;
 ultrasonic4 = (echo4 / 2) * soundcm;
}

void Infrared()
{
    if (mySerial.available())
    {
      int x = mySerial.read();
      Serial.println(x);
      if ( x >= 48 && x <= 51|| x >= 248 && x <= 255)
      {
        Serial.println("light found");
      }
    else
    {
      Serial.println("light NOT found");
    }
  }
}
