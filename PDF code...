#include <Servo.h>
#include <EEPROM.h>
#include <uSTimer2.h>
#include <CharliePlexM.h>
#include <Wire.h>
#include <I2CEncoder.h>
#include <StackArray.h>
#include "NewPing.h"
#include <SoftwareSerial.h>

Servo servo_RightMotor;
Servo servo_LeftMotor;
Servo servo_SweeperMotor;
Servo servo_ScooperMotor;

I2CEncoder encoder_RightMotor;
I2CEncoder encoder_LeftMotor;

class Movement
{
  public:
    int move;
    unsigned long time;
};
StackArray <Movement> stack;
unsigned int stackSize;

//Infared Setup
SoftwareSerial mySerial(2, 13); // RX, TX

boolean bt_Motors_Enabled = true;

//port pin constants
const int ci_Light_Sensor = 2;
const int ci_Charlieplex_LED1 = 4;
const int ci_Charlieplex_LED2 = 5;
const int ci_Charlieplex_LED3 = 6;
const int ci_Charlieplex_LED4 = 7;
const int ci_Mode_Button = 7;
const int ci_Right_Motor = 8;
const int ci_Left_Motor = 9;
const int ci_Scooper_Motor = 10;
const int ci_Sweeper_Motor = 11;
const int ci_Motor_Enable_Switch = 12;
const int ci_I2C_SDA = A4;         // I2C data = white
const int ci_I2C_SCL = A5;         // I2C clock = yellow
#define Ultrasonic_Ping1  A0 //front Sensor
#define Ultrasonic_Data1  A0
#define Ultrasonic_Ping2  A1 //left sesnor 
#define Ultrasonic_Data2  A1
#define Ultrasonic_Ping3  A2 //right sesnot
#define Ultrasonic_Data3  A2
#define Ultrasonic_Ping4  A3 //backward facing sensor
#define Ultrasonic_Data4  A3
#define MAX_DISTANCE 400

//Ultrasonic Setup
NewPing sonar1(Ultrasonic_Ping1, Ultrasonic_Data1, MAX_DISTANCE);
NewPing sonar2(Ultrasonic_Ping2, Ultrasonic_Data2, MAX_DISTANCE);
NewPing sonar3(Ultrasonic_Ping3, Ultrasonic_Data3, MAX_DISTANCE);
NewPing sonar4(Ultrasonic_Ping4, Ultrasonic_Data4, MAX_DISTANCE); //for backward facing ul sensor
float echo1; // Stores calculated distance in cm for First Sensor
float echo2; // Stores calculated distance in cm for Second Sensor
float echo3; // Stores calculated distance in cm for Third Sensor
float echo4; // Stores calculated distance in cm for Fourth Sensor
float soundsp;  // Stores calculated speed of sound in M/S
float soundcm;  // Stores calculated speed of sound in cm/ms
int iterations = 2;
unsigned int ultrasonic1;
unsigned int ultrasonic2;
unsigned int ultrasonic3;
unsigned int ultrasonic4;

//constants
const int Motor_Stop = 1500;        // 200 for brake mode; 1500 for stop
const int Motor_Brake = 200;
const int ci_Scooper_Motor_Up = 160;
const int ci_Scooper_Motor_Down = 65;
const int ul_front_D = 29;
const int ul_side_D = 31;
const int ul_back_D = 3;
const int Left_Motor_Offset = 15;

//variables
unsigned int ui_Left_Motor_Speed;
unsigned int ui_Right_Motor_Speed;
unsigned int ul_3_Second_timer = 0;
unsigned int ui_Cal_Cycle;
unsigned int currentMove;
unsigned long currentTime;
unsigned long currentMillis;
unsigned long startVal;
unsigned long startTime, endTime;
unsigned long newStartTime, newEndTime;

//******* DONT INCLUDE********/////////
unsigned int  ui_Robot_State_Index = 0;
//0123456789ABCDEF
unsigned int  ui_Mode_Indicator[6] = {
  0x00,    //B0000000000000000,  //Stop
  0x00FF,  //B0000000011111111,  //Run
  0x0F0F,  //B0000111100001111,  //Calibrate line tracker light level
  0x3333,  //B0011001100110011,  //Calibrate line tracker dark level
  0xAAAA,  //B1010101010101010,  //Calibrate motors
  0xFFFF   //B1111111111111111   //Unused
};
unsigned int  ui_Mode_Indicator_Index = 0;
//display Bits 0,1,2,3, 4, 5, 6,  7,  8,  9,  10,  11,  12,  13,   14,   15
int  iArray[16] = {
  1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 65536
};
int  iArrayIndex = 0;
boolean bt_Heartbeat = true;
boolean bt_3_S_Time_Up = false;
boolean bt_45_S_Time_Up = false;
boolean bt_Do_Once = false;
boolean bt_Cal_Initialized = false;

//flags
bool flag_1 = true;
bool flag_2A = true;
bool flag_2B = false;
bool flag_2C = true;
bool flag_3A = true;
bool flag_3B = false;
bool flag_3C = true;
bool flag_4A = true;
bool flag_4B = false;
bool flag_4C = true;
bool flag_5A = true;
bool flag_5B = false;
bool flag_5C = true;
bool flag_6A = true;
bool flag_6B = false;
bool flag_6C = true;
bool flag_7A = true;
bool flag_7B = false;
bool flag_7C = true;
bool flag_8A = true;
bool flag_8B = false;
bool flag_8C = true;
bool A = true;
bool B = true;
bool C = true;
bool D = true;
bool flag_2B_reversed = false;
bool flag_2C_reversed = true;
bool flag_3B_reversed = false;
bool flag_3C_reversed = true;
bool flag_4B_reversed = false;
bool flag_4C_reversed = true;
bool flag_5B_reversed = false;
bool flag_5C_reversed = true;
bool flag_6B_reversed = false;
bool flag_6C_reversed = true;
bool flag_7B_reversed = false;
bool flag_7C_reversed = true;
bool flag_8B_reversed = false;
bool flag_8C_reversed = true;
bool Phase1 = true;
bool Phase2 = false;
bool Phase3 = true;
bool IR_ON = false;
bool IR1 = false;
bool IR2 = true;
bool comm_flag = true;
bool stack_empty;


void setup()
{
  Wire.begin();// Wire library required for I2CEncoder library
  Serial.begin(9600);
  mySerial.begin(2400);
  CharliePlexM::setBtn(ci_Charlieplex_LED1, ci_Charlieplex_LED2, ci_Charlieplex_LED3, ci_Charlieplex_LED4, ci_Mode_Button);

  // set up drive motors
  pinMode(ci_Right_Motor, OUTPUT);
  servo_RightMotor.attach(ci_Right_Motor);
  pinMode(ci_Left_Motor, OUTPUT);
  servo_LeftMotor.attach(ci_Left_Motor);
  // set up scooper motor
  pinMode(ci_Scooper_Motor, OUTPUT);
  servo_ScooperMotor.attach(ci_Scooper_Motor);

  // set up encoders
  encoder_LeftMotor.init(1.0 / 3.0 * MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);
  encoder_LeftMotor.setReversed(false);  // adjust for positive count when moving forward
  encoder_RightMotor.init(1.0 / 3.0 * MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);
  encoder_RightMotor.setReversed(true);  // adjust for positive count when moving forward
}

void loop()
{
  //3 seconds timer flag
  if ((millis() - ul_3_Second_timer) > 3000)
  {
    bt_3_S_Time_Up = true;
  }

  // button-based mode selection
  if (CharliePlexM::ui_Btn)
  {
    if (bt_Do_Once == false)
    {
      bt_Do_Once = true;
      ui_Robot_State_Index++;
      ui_Robot_State_Index = ui_Robot_State_Index & 7;
      ul_3_Second_timer = millis();
      bt_3_S_Time_Up = false;
      bt_Cal_Initialized = false;
      ui_Cal_Cycle = 0;
    }
  }
  else
  {
    bt_Do_Once = LOW;
  }
  bt_Motors_Enabled = digitalRead(ci_Motor_Enable_Switch);


  switch (ui_Robot_State_Index)
  {
    case 0: //Robot stopped
      {
        Ping();
        servo_ScooperMotor.write(58);
        servo_LeftMotor.writeMicroseconds(Motor_Stop);
        servo_RightMotor.writeMicroseconds(Motor_Stop);
        break;
      }

    case 1:  //Robot Run after 3 seconds
      {
        Ping();
        Infrared();
        servo_ScooperMotor.write(65);
        if ( stackSize >= 5 || bt_45_S_Time_Up && Phase2 == true)
        {
          Phase2 = false;
          Phase3 = true;
        }

        if (Phase1 == true)
        {
          if (bt_3_S_Time_Up)
          {
            if (ultrasonic1 > ul_front_D && A == true) // go foward if nothing is at front
            {
              if (flag_1 == true)
              {
                startTime = millis(); // start time
                flag_1 = false;
              }
              servo_RightMotor.writeMicroseconds(1700); // go forward
              servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
            }
            else if ((ultrasonic1 < ul_front_D || ultrasonic2 < ul_side_D || ultrasonic3 < ul_side_D) && A == true )
            {
              endTime = millis(); // end time
              currentTime = endTime - startTime;
              A = false;
            }
            if (A == false && B == true)
            {
              newStartTime = millis();
              if (C == true)
              {
                newEndTime = newStartTime + currentTime;
                C = false;
              }
              if (newStartTime < newEndTime)
              {
                servo_RightMotor.writeMicroseconds(1300); // go backward
                servo_LeftMotor.writeMicroseconds(1300);
              }
              else
              {
                servo_RightMotor.writeMicroseconds(1500); //stop
                servo_LeftMotor.writeMicroseconds(1500);
                B = false;
              }
            }
            if (A == false && B == false)
            {
              servo_ScooperMotor.write(58);
              for (int i = 60; i < 160; i += 3)
              {
                delay(50);
                servo_ScooperMotor.write(i);
              }
              delay(1000);
              servo_ScooperMotor.write(65);
              Phase1 = false;
              B = true;
              A = true;
              flag_1 = true;
            }
          }
        }
        if (Phase1 == false)
        {
          if (Phase2 == true)
          {
            if (ultrasonic1 > ul_front_D && ultrasonic2 > ul_side_D && ultrasonic3 > ul_side_D && flag_1 == true) //Case 1: no objects nearby, drive straight
            {
              if (A == true)
              {
                startTime = millis();
                A = false;
              }


              servo_RightMotor.writeMicroseconds(1700);
              servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
            }

            else if (ultrasonic1 <= ul_front_D  && ultrasonic2 <= ul_side_D && ultrasonic3 <= ul_side_D && flag_2A == true) //Case 2: object in front, AND object on left, AND object on right. back up turn 180deg
            {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();

                A = true;
              }
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;

              flag_2B = true;
            }
            if (flag_2B == true)
            {
              currentMillis = millis();
              if (flag_2C == true) // start timer
              {
                startVal = currentMillis;
                flag_2C = false;
              }
              if (flag_2C == false)
              {
                if ((currentMillis - startVal) < 400) //back up slightly after .4 seconds
                {
                  servo_RightMotor.writeMicroseconds(1400);
                  servo_LeftMotor.writeMicroseconds(1400);
                }
                else if ((currentMillis - startVal) > 400 && (currentMillis - startVal) < 1200) //turn 180
                {
                  servo_RightMotor.writeMicroseconds(1700);
                  servo_LeftMotor.writeMicroseconds(1300);
                }
                else if ((currentMillis - startVal) > 1200)
                {
                  flag_1 = true;
                  flag_2A = true;
                  flag_3A = true;
                  flag_4A = true;
                  flag_5A = true;
                  flag_6A = true;
                  flag_7A = true;
                  flag_8A = true;

                  flag_2B = false;
                  flag_2C = true;

                  Movement T;
                  T.move = 2;
                  T.time = 1200;
                  stack.push(T);
                  stackSize = stack.count();
                }
              }
            }

            else if (ultrasonic1 <= ul_front_D && ultrasonic2 > ul_side_D && ultrasonic3 > ul_side_D && flag_3A == true) //Case 3: object in front, no object on left, no object on right. back up, turn left (can be right too)
            {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                A = true;
              }
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;


              flag_3B = true;
            }
            if (flag_3B == true)
            {
              currentMillis = millis();


              if (flag_3C == true) // start timer
              {
                startVal = currentMillis;
                flag_3C = false;
              }
              if (flag_3C == false)
              {
                if ((currentMillis - startVal) < 400) //back up slightly after .4 seconds
                {
                  servo_RightMotor.writeMicroseconds(1400);
                  servo_LeftMotor.writeMicroseconds(1400);
                }
                else if ((currentMillis - startVal) > 400 && (currentMillis - startVal) < 1000) //turn left 225deg
                {
                  servo_RightMotor.writeMicroseconds(1700);
                  servo_LeftMotor.writeMicroseconds(1300);
                }
                else if ((currentMillis - startVal) > 1000)
                {
                  flag_1 = true;
                  flag_2A = true;

                  flag_3A = true;
                  flag_4A = true;
                  flag_5A = true;
                  flag_6A = true;
                  flag_7A = true;
                  flag_8A = true;

                  flag_3B = false;
                  flag_3C = true;

                  Movement T;
                  T.move = 3;
                  T.time = 1000;
                  stack.push(T);
                  stackSize = stack.count();


                }
              }
            }

            else if (ultrasonic1 > ul_front_D && ultrasonic2 > ul_side_D && ultrasonic3 <= ul_side_D && flag_4A == true) //Case 4: NO object in front, no object on left, AND object on right, turn left 90deg
            {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();


                Movement T;
                T.move = 1;
                T.time = endTime - startTime;


                stack.push(T);
                stackSize = stack.count();


                A = true;

              }
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;

              flag_4B = true;
            }
            if (flag_4B == true)
            {
              currentMillis = millis();


              if (flag_4C == true) // start timer
              {
                startVal = currentMillis;
                flag_4C = false;
              }
              if (flag_4C == false)
              {
                if ((currentMillis - startVal) < 400) //turn left 90deg
                {
                  servo_RightMotor.writeMicroseconds(1700);
                  servo_LeftMotor.writeMicroseconds(1300);
                }
                else if ((currentMillis - startVal) > 400)
                {
                  flag_1 = true;
                  flag_2A = true;
                  flag_3A = true;
                  flag_4A = true;
                  flag_5A = true;
                  flag_6A = true;
                  flag_7A = true;
                  flag_8A = true;

                  flag_4B = false;
                  flag_4C = true;

                  Movement T;
                  T.move = 4;
                  T.time = 400;
                  stack.push(T);
                  stackSize = stack.count();


                }
              }
            }

            if (ultrasonic1 > ul_front_D && ultrasonic2 <= ul_side_D && ultrasonic3 > ul_side_D && flag_5A == true) //Case 5: NO object in front, AND object on left, no object on right, turn right 90deg
            {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();


                Movement T;
                T.move = 1;
                T.time = endTime - startTime;


                stack.push(T);
                stackSize = stack.count();


                A = true;

              }
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;

              flag_5B = true;
            }
            if (flag_5B == true)
            {
              currentMillis = millis();



              if (flag_5C == true) // start timer
              {
                startVal = currentMillis;
                flag_5C = false;
              }
              if (flag_5C == false)
              {
                if ((currentMillis - startVal) < 400) //turn right 90deg
                {
                  servo_RightMotor.writeMicroseconds(1300);
                  servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
                }
                else if ((currentMillis - startVal) > 400)
                {
                  flag_1 = true;
                  flag_2A = true;
                  flag_3A = true;
                  flag_4A = true;
                  flag_5A = true;
                  flag_6A = true;
                  flag_7A = true;
                  flag_8A = true;

                  flag_5B = false;
                  flag_5C = true;

                  Movement T;
                  T.move = 5;
                  T.time = 400;
                  stack.push(T);
                  stackSize = stack.count();


                }
              }
            }

            else if (ultrasonic1 <= ul_front_D && ultrasonic2 <= ul_side_D && ultrasonic3 > ul_side_D && flag_6A == true) //Case 6: object in front, AND object on left, no object on right. back up turn right 90deg
            {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();


                Movement T;
                T.move = 1;
                T.time = endTime - startTime;


                stack.push(T);
                stackSize = stack.count();


                A = true;

              }
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;

              flag_6B = true;
            }
            if (flag_6B == true)
            {
              currentMillis = millis();


              if (flag_6C == true) // start timer
              {
                startVal = currentMillis;
                flag_6C = false;
              }
              if (flag_6C == false)
              {
                if ((currentMillis - startVal) < 400) //back up slightly after .4 seconds
                {
                  servo_RightMotor.writeMicroseconds(1400);
                  servo_LeftMotor.writeMicroseconds(1400);
                }
                else if ((currentMillis - startVal) > 400 && (currentMillis - startVal) < 800) //turn right
                {
                  servo_RightMotor.writeMicroseconds(1300);
                  servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
                }
                else if ((currentMillis - startVal) > 800)
                {
                  flag_1 = true;
                  flag_2A = true;
                  flag_3A = true;
                  flag_4A = true;
                  flag_5A = true;
                  flag_6A = true;
                  flag_7A = true;
                  flag_8A = true;

                  flag_6B = false;
                  flag_6C = true;

                  Movement T;
                  T.move = 6;
                  T.time = 800;
                  stack.push(T);
                  stackSize = stack.count();


                }
              }
            }

            else if (ultrasonic1 <= ul_front_D && ultrasonic2 > ul_side_D && ultrasonic3 <= ul_side_D && flag_7A == true) //Case 7: object in front, no object on left, AND object on right. back up turn left 90deg
            {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();


                Movement T;
                T.move = 1;
                T.time = endTime - startTime;


                stack.push(T);
                stackSize = stack.count();


                A = true;

              }
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;

              flag_7B = true;
            }
            if (flag_7B == true)
            {
              currentMillis = millis();


              if (flag_7C == true) // start timer
              {
                startVal = currentMillis;
                flag_7C = false;
              }
              if (flag_7C == false)
              {
                if ((currentMillis - startVal) < 400) //back up slightly after .4 seconds
                {
                  servo_RightMotor.writeMicroseconds(1400);
                  servo_LeftMotor.writeMicroseconds(1400);
                }
                else if ((currentMillis - startVal) > 400 && (currentMillis - startVal) < 800) //turn left
                {
                  servo_RightMotor.writeMicroseconds(1700);
                  servo_LeftMotor.writeMicroseconds(1300);
                }
                else if ((currentMillis - startVal) > 800)
                {
                  flag_1 = true;
                  flag_2A = true;
                  flag_3A = true;
                  flag_4A = true;
                  flag_5A = true;
                  flag_6A = true;
                  flag_7A = true;
                  flag_8A = true;

                  flag_7B = false;
                  flag_7C = true;

                  Movement T;
                  T.move = 7;
                  T.time = 800;
                  stack.push(T);
                  stackSize = stack.count();


                }
              }
            }

            else if (ultrasonic1 > ul_front_D && ultrasonic2 <= ul_side_D && ultrasonic3 <= ul_side_D && flag_8A == true) //Case 8: no object in front, AND object on left, AND object on right. straight
            {
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              flag_1 = false;
              if (A == false)
              {
                endTime = millis();
                Movement T;
                T.move = 1;
                T.time = endTime - startTime;
                stack.push(T);
                stackSize = stack.count();
                A = true;
              }
              flag_2A = false;
              flag_3A = false;
              flag_4A = false;
              flag_5A = false;
              flag_6A = false;
              flag_7A = false;
              flag_8A = false;

              flag_8B = true;
            }
            if (flag_8B == true)
            {
              currentMillis = millis();


              if (flag_8C == true) // start timer
              {
                startVal = currentMillis;
                flag_8C = false;
              }
              if (flag_8C == false)
              {
                if ((currentMillis - startVal) < 400) //back up slightly after .4 seconds
                {
                  servo_RightMotor.writeMicroseconds(1400);
                  servo_LeftMotor.writeMicroseconds(1400);
                }
                else if ((currentMillis - startVal) > 400 && (currentMillis - startVal) < 1200) //turn 180
                {
                  servo_RightMotor.writeMicroseconds(1700);
                  servo_LeftMotor.writeMicroseconds(1300);
                }
                else if ((currentMillis - startVal) > 1200)
                {
                  flag_1 = true;
                  flag_2A = true;
                  flag_3A = true;
                  flag_4A = true;
                  flag_5A = true;
                  flag_6A = true;
                  flag_7A = true;
                  flag_8A = true;

                  flag_8B = false;
                  flag_8C = true;

                  Movement T;
                  T.move = 8;
                  T.time = 1200;
                  stack.push(T);
                  stackSize = stack.count();


                }
              }
            }
          }
          else if (Phase3 == true) //begin first return home
          {
            // save case 1 if its running while timer ends
            if (A == false)
            {
              endTime = millis();
              Movement T;
              T.move = 1;
              T.time = endTime - startTime;
              stack.push(T);
              stackSize = stack.count();


              A = true;
            }


            // flag to check if stack is empty: 0 = full, 1 = empty

            if (D == true) // check if stack is empty
            {
              stack_empty = stack.isEmpty();


              D = false;
            }

            if (B == true && stack_empty == false)
            {

              Movement lastMove;
              lastMove = stack.pop();
              stackSize = stack.count();


              currentMove = lastMove.move;
              currentTime = lastMove.time;
              B = false;
              C = true;
            }
            if (B == false && stack_empty == false)
            {
              if (currentMove == 1 && B == false)
              {
                newStartTime = millis();


                if (C == true)
                {
                  newEndTime = newStartTime + currentTime;


                  C = false;
                }
                if ( newStartTime < newEndTime )
                {
                  servo_RightMotor.writeMicroseconds(1300);
                  servo_LeftMotor.writeMicroseconds(1300);
                }
                else
                {
                  servo_RightMotor.writeMicroseconds(1500);
                  servo_LeftMotor.writeMicroseconds(1500);
                  B = true;
                  D = true;
                }
              }
              if (currentMove == 2 && B == false)
              {
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);

                flag_2B_reversed = true;
                if (flag_2B_reversed == true)
                {
                  currentMillis = millis();
                  if (flag_2C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_2C_reversed = false;
                  }
                  if (flag_2C_reversed == false)
                  {
                    if ((currentMillis - startVal) < 800) //turn 180
                    {
                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);

                    }
                    else if ((currentMillis - startVal) > 800 && (currentMillis - startVal) < 1200) //go forward slightly
                    {
                      servo_RightMotor.writeMicroseconds(1600);
                      servo_LeftMotor.writeMicroseconds(1600 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 1200)
                    {
                      flag_2B_reversed = false;
                      flag_2C_reversed = true;
                      B = true;
                    }
                  }
                }
              }
              if (currentMove == 3 && B == false)
              {
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);

                flag_3B_reversed = true;

                if (flag_3B_reversed == true)
                {
                  currentMillis = millis();


                  if (flag_3C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_3C_reversed = false;
                  }
                  if (flag_3C_reversed == false)
                  {
                    if ((currentMillis - startVal) < 700) //turn right .6 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1250);
                      servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 700 && (currentMillis - startVal) < 1100) //drive straight .4 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1600);
                      servo_LeftMotor.writeMicroseconds(1600 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 1100)
                    {
                      flag_3B_reversed = false;
                      flag_3C_reversed = true;
                      B = true;
                    }
                  }
                }
              }
              if (currentMove == 4 && B == false)
              {
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);

                flag_4B_reversed = true;

                if (flag_4B_reversed == true)
                {
                  currentMillis = millis();

                  if (flag_4C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_4C_reversed = false;
                  }
                  if (flag_4C_reversed == false)
                  {
                    if ((currentMillis - startVal) < 400) //turn right 90deg
                    {


                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 400)
                    {
                      flag_4B_reversed = false;
                      flag_4C_reversed = true;
                      B = true;
                    }
                  }
                }
              }
              if (currentMove == 5 && B == false)
              {
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);
                flag_5B_reversed = true;
                if (flag_5B_reversed == true)
                {
                  currentMillis = millis()
                                  ;
                  if (flag_5C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_5C_reversed = false;
                  }
                  if (flag_5C_reversed == false)
                  {
                    if ((currentMillis - startVal) < 500) //turn left 90deg
                    {


                      servo_RightMotor.writeMicroseconds(1700);
                      servo_LeftMotor.writeMicroseconds(1300);
                    }
                    else if ((currentMillis - startVal) > 500)
                    {
                      flag_5B_reversed = false;
                      flag_5C_reversed = true;
                      B = true;
                    }
                  }
                }
              }
              if (currentMove == 6 && B == false)
              {
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);

                flag_6B_reversed = true;

                if (flag_6B_reversed == true)
                {
                  currentMillis = millis();


                  if (flag_6C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_6C_reversed = false;
                  }
                  if (flag_6C_reversed == false)
                  {
                    if ((currentMillis - startVal) < 400) //turn left 90deg
                    {
                      servo_RightMotor.writeMicroseconds(1700);
                      servo_LeftMotor.writeMicroseconds(1300);
                    }
                    else if ((currentMillis - startVal) > 400 && (currentMillis - startVal) < 800) //drive stright 0.4s
                    {
                      servo_RightMotor.writeMicroseconds(1600);
                      servo_LeftMotor.writeMicroseconds(1600 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 800)
                    {
                      flag_6B_reversed = false;
                      flag_6C_reversed = true;
                      B = true;
                    }
                  }
                }
              }
              if (currentMove == 7 && B == false)
              {
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);

                flag_7B_reversed = true;

                if (flag_7B_reversed == true)
                {
                  currentMillis = millis();


                  if (flag_6C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_7C_reversed = false;
                  }
                  if (flag_7C_reversed == false)
                  {
                    if ((currentMillis - startVal) < 400) //turn right 90deg
                    {
                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 400 && (currentMillis - startVal) < 800) //drive stright 0.4s
                    {
                      servo_RightMotor.writeMicroseconds(1600);
                      servo_LeftMotor.writeMicroseconds(1600 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 800)
                    {
                      flag_7B_reversed = false;
                      flag_7C_reversed = true;
                      B = true;
                    }
                  }
                }
              }
              if (currentMove == 8 && B == false)
              {
                servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
                servo_RightMotor.writeMicroseconds(Motor_Stop);

                flag_8B_reversed = true;
                if (flag_8B_reversed == true)
                {
                  currentMillis = millis();
                  if (flag_8C_reversed == true) // start timer
                  {
                    startVal = currentMillis;
                    flag_8C_reversed = false;
                  }
                  if (flag_8C_reversed == false)
                  {
                    if ((currentMillis - startVal) < 800) //turn 180
                    {
                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 800 && (currentMillis - startVal) < 1200) //go forward slightly
                    {
                      servo_RightMotor.writeMicroseconds(1600);
                      servo_LeftMotor.writeMicroseconds(1600 + Left_Motor_Offset);
                    }
                    else if ((currentMillis - startVal) > 1200)
                    {
                      flag_8B_reversed = false;
                      flag_8C_reversed = true;
                      B = true;
                    }
                  }
                }
              }
            }
            if (stack_empty == true)
            {
              ReturnHome();
              if (!comm_flag)
              {
                Phase2 = true;
                Phase3 = false;
                comm_flag = true;
              }
            }
            break;
          }
        }
      }
  }
}



// measure distance to target using ultrasonic sensor
void Ping()
{
  soundsp = 331.4; // Calculate the Speed of Sound in M/S
  soundcm = soundsp / 10000;  // Convert to cm/ms

  echo1 = sonar1.ping_median(iterations); // Measure duration for first sensor (front)
  echo2 = sonar2.ping_median(iterations); // Measure duration for second sensor (left)
  echo3 = sonar3.ping_median(iterations); // Measure duration for third sensor (right)
  echo4 = sonar4.ping_median(iterations); // Measure duration for fourth sensor (back)

  if (echo1) {
    ultrasonic1 = (echo1 / 2) * soundcm;
  }
  if (echo2) {
    ultrasonic2 = (echo2 / 2) * soundcm;
  }
  if (echo3) {
    ultrasonic3 = (echo3 / 2) * soundcm;
  }
  if (echo4) {
    ultrasonic4 = (echo4 / 2) * soundcm;
  }
}
void ReturnHome ()
{
  if (IR_ON == true && ultrasonic4 > ul_back_D && IR1 == false) // Case 1: IR on, UL off. Drive backwards
  {
    servo_RightMotor.writeMicroseconds(1390);
    servo_LeftMotor.writeMicroseconds(1400);
  }
  else if (IR_ON == false && ultrasonic4 > ul_back_D && IR1 == false) //Case 2: IR OFF, UL off. Rotate 360
  {
    servo_RightMotor.writeMicroseconds(1600);
    servo_LeftMotor.writeMicroseconds(1400);
  }
  else if (IR_ON == false && ultrasonic4 <= ul_back_D && IR1 == false)// Case 3: IR OFF, UL on. Stop. Back up (go forward)
  {

    IR1 = true;
  }

  if (IR1 == true)
  {
    currentMillis = millis();
    IR2 = true;

    if (IR2 == true) // start timer
    {
      startVal = currentMillis;
      IR2 = false;
    }
    if (IR2 == false)
    {
      if ((currentMillis - startVal) < 800)
      {


        servo_RightMotor.writeMicroseconds(1600);
        servo_LeftMotor.writeMicroseconds(1600 + Left_Motor_Offset);
      }
      else if ((currentMillis - startVal) > 800)
      {
        IR1 = false;
        // IR2 = true;
      }
    }
    //    servo_RightMotor.writeMicroseconds(1600);
    //    servo_LeftMotor.writeMicroseconds(1600 + Left_Motor_Offset);
  }
  else if (IR_ON == true && ultrasonic4 <= ul_back_D && IR1 == false) // Case 4 / Last step : IR on, UL on. Stop, Dump.
  {
    servo_RightMotor.writeMicroseconds(1500);
    servo_LeftMotor.writeMicroseconds(1500);
    servo_ScooperMotor.write(58);
    for (int i = 60; i < 160; i += 3)
    {
      delay(50);
      servo_ScooperMotor.write(i);
    }
    delay(1000);
    servo_ScooperMotor.write(65);
    comm_flag = false;
  }
}


void Infrared()
{
  if (mySerial.available())
  {
    int x = mySerial.read();
    if ((x >= 49 && x <= 51) || x == 66)
    {
      IR_ON = true;
    }
    else
    {
      IR_ON = false;
    }
    while (mySerial.available()) {
      int trash = mySerial.read();
    }
  }
  else
  {
    IR_ON = false;
  }
}
