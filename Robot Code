#include <Servo.h>
#include <EEPROM.h>
#include <uSTimer2.h>
#include <CharliePlexM.h>
#include <Wire.h>
#include <I2CEncoder.h>
#include <StackArray.h>

Servo servo_RightMotor;
Servo servo_LeftMotor;
Servo servo_SweeperMotor;
Servo servo_ScooperMotor;

I2CEncoder encoder_RightMotor;
I2CEncoder encoder_LeftMotor;

class Movement
{
  public:
    int move;
    unsigned long time;
};

 StackArray <Movement> stack;

// Uncomment keywords to enable debugging output
  //#define DEBUG_MODE_DISPLAY
  //#define DEBUG_MOTORS
  //#define DEBUG_ENCODERS
  //#define DEBUG_ULTRASONIC
  //#define DEBUG_LINE_TRACKER_CALIBRATION
  //#define DEBUG_MOTOR_CALIBRATION

boolean bt_Motors_Enabled = true;

//port pin constants
const int Ultrasonic_Ping1 = 2;   //input plug
const int Ultrasonic_Data1 = 3;   //output plug
const int ci_Charlieplex_LED1 = 4;
const int ci_Charlieplex_LED2 = 5;
const int ci_Charlieplex_LED3 = 6;
const int ci_Charlieplex_LED4 = 7;
const int ci_Mode_Button = 7;
const int ci_Right_Motor = 8;
const int ci_Left_Motor = 9;
const int ci_Scooper_Motor = 10;
const int ci_Light_Sensor = 11;
const int ci_Motor_Enable_Switch = 12;
//const int (insert motor / sensor here) = 13;
const int Ultrasonic_Ping2 = A0; //input plug
const int Ultrasonic_Data2 = A1; //output plug
const int Ultrasonic_Ping3 = A2; //input plug
const int Ultrasonic_Data3 = A3; //output plug
const int ci_I2C_SDA = A4;         // I2C data = white
const int ci_I2C_SCL = A5;         // I2C clock = yellow

unsigned long ultrasonic1;
unsigned long ultrasonic2;
unsigned long ultrasonic3;

// Charlieplexing LED assignments
const int ci_Heartbeat_LED = 1;
const int ci_Indicator_LED = 4;
//const int ci_Right_Line_Tracker_LED = 6;
//const int ci_Middle_Line_Tracker_LED = 9;
//const int ci_Left_Line_Tracker_LED = 12;

//constants

// EEPROM addresses
const int ci_Left_Motor_Offset_Address_L = 12;
const int ci_Left_Motor_Offset_Address_H = 13;
const int ci_Right_Motor_Offset_Address_L = 14;
const int ci_Right_Motor_Offset_Address_H = 15;

const int Motor_Stop = 1500;        // 200 for brake mode; 1500 for stop
const int Motor_Brake = 200;
const int ci_Scooper_Motor_Up = 140;
const int ci_Scooper_Motor_Down = 20;

const int ul_front_D = 10;
const int ul_side_D = 12;

const int ci_Display_Time = 500;
const int ci_Motor_Calibration_Cycles = 3;
const int ci_Motor_Calibration_Time = 5000;

//variables
byte b_LowByte;
byte b_HighByte;
unsigned int ui_Motors_Speed = 1900;        // Default run speed
unsigned int ui_Left_Motor_Speed;
unsigned int ui_Right_Motor_Speed;
int Left_Motor_Position;
int Right_Motor_Position;

unsigned long ul_3_Second_timer = 0;
unsigned long ul_45_Second_timer = 0;
unsigned long ul_Display_Time;
unsigned long ul_Calibration_Time;
unsigned long ui_Left_Motor_Offset;
unsigned long ui_Right_Motor_Offset;

unsigned int ui_Cal_Count;
unsigned int ui_Cal_Cycle;

unsigned int  ui_Robot_State_Index = 0;
//0123456789ABCDEF
unsigned int  ui_Mode_Indicator[6] = {
  0x00,    //B0000000000000000,  //Stop
  0x00FF,  //B0000000011111111,  //Run
  0x0F0F,  //B0000111100001111,  //Calibrate line tracker light level
  0x3333,  //B0011001100110011,  //Calibrate line tracker dark level
  0xAAAA,  //B1010101010101010,  //Calibrate motors
  0xFFFF   //B1111111111111111   //Unused
};

unsigned int  ui_Mode_Indicator_Index = 0;

//display Bits 0,1,2,3, 4, 5, 6,  7,  8,  9,  10,  11,  12,  13,   14,   15
int  iArray[16] = {
  1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,65536};
int  iArrayIndex = 0;

boolean bt_Heartbeat = true;
boolean bt_3_S_Time_Up = false;
boolean bt_45_S_Time_Up = false;
boolean bt_Do_Once = false;
boolean bt_Cal_Initialized = false;

//flags
  bool flag_1 = true; 
  
  bool flag_2A = true; 
  bool flag_2B = false; 
  bool flag_2C = true; 
  
  bool flag_3A = true; 
  bool flag_3B = false; 
  bool flag_3C = true; 

  bool flag_4A = true;
  bool flag_4B = false; 
  bool flag_4C = true; 

  bool flag_5A = true;
  bool flag_5B = false; 
  bool flag_5C = true; 

  bool flag_6A = true;
  bool flag_6B = false; 
  bool flag_6C = true; 

  bool flag_7A = true;
  bool flag_7B = false; 
  bool flag_7C = true; 

  bool flag_8A = true;
  bool flag_8B = false; 
  bool flag_8C = true; 
  
  bool A = true;
  bool B = true;
  bool C = true;

  bool flag_2B_reversed = false;
  bool flag_2C_reversed = true;

  bool flag_3B_reversed = false;
  bool flag_3C_reversed = true;
  

 long currentMove, currentTime;
unsigned long currentMillis, currentMillis_reversed;
unsigned long startVal, startVal_reversed;
unsigned long startTime, endTime;
unsigned long newStartTime, newEndTime;


void setup() 
{
  Wire.begin();// Wire library required for I2CEncoder library
  Serial.begin(9600);

  CharliePlexM::setBtn(ci_Charlieplex_LED1,ci_Charlieplex_LED2,ci_Charlieplex_LED3,ci_Charlieplex_LED4,ci_Mode_Button);

  //Set up Front facing ultrasonic sensor
    pinMode(Ultrasonic_Ping1, OUTPUT);
    pinMode(Ultrasonic_Data1, INPUT);
  // Set up Left facing ultrasonic sensor
    pinMode(Ultrasonic_Ping2, OUTPUT);
    pinMode(Ultrasonic_Data2, INPUT);
  // Set up Right facing ultrasonic sensor
    pinMode (Ultrasonic_Ping3, OUTPUT);
    pinMode (Ultrasonic_Data3, INPUT);

  // set up drive motors
    pinMode(ci_Right_Motor, OUTPUT);
    servo_RightMotor.attach(ci_Right_Motor);
    pinMode(ci_Left_Motor, OUTPUT);
    servo_LeftMotor.attach(ci_Left_Motor);

  // set up scooper motor
 pinMode(ci_Scooper_Motor, OUTPUT);
servo_ScooperMotor.attach(ci_Scooper_Motor);

  // set up encoders. Must be initialized in order that they are chained together, 
  // starting with the encoder directly connected to the Arduino
    encoder_LeftMotor.init(1.0/3.0*MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);
    encoder_LeftMotor.setReversed(false);  // adjust for positive count when moving forward
    encoder_RightMotor.init(1.0/3.0*MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);  
    encoder_RightMotor.setReversed(true);  // adjust for positive count when moving forward

  // read saved values from EEPROM
  b_LowByte = EEPROM.read(ci_Left_Motor_Offset_Address_L);
  b_HighByte = EEPROM.read(ci_Left_Motor_Offset_Address_H);
  ui_Left_Motor_Offset = word(b_HighByte, b_LowByte);
  b_LowByte = EEPROM.read(ci_Right_Motor_Offset_Address_L);
  b_HighByte = EEPROM.read(ci_Right_Motor_Offset_Address_H);
  ui_Right_Motor_Offset = word(b_HighByte, b_LowByte);
}

void loop()
{
  //3 seconds timer flag
  if((millis() - ul_3_Second_timer) > 3000)
  {
    bt_3_S_Time_Up = true;
  }
  //45 second timer flag
  if ( (millis() - ul_45_Second_timer) > 10000)
  {
     bt_45_S_Time_Up = true;
  }

  // button-based mode selection
  if(CharliePlexM::ui_Btn)
  {
    if(bt_Do_Once == false)
    {
      bt_Do_Once = true;
      ui_Robot_State_Index++;
      ui_Robot_State_Index = ui_Robot_State_Index & 7;
      ul_3_Second_timer = millis();
      bt_3_S_Time_Up = false;
      bt_Cal_Initialized = false;
      ui_Cal_Cycle = 0;
    }
  }
  else
  {
    bt_Do_Once = LOW;
  }

  // check if drive motors should be powered
  bt_Motors_Enabled = digitalRead(ci_Motor_Enable_Switch);

  // modes 
  // 0 = default after power up/reset
  // 1 = Press mode button once to enter. Run robot.
  // 2 = Press mode button twice to enter. Calibrate line tracker light level.
  // 3 = Press mode button three times to enter. Calibrate line tracker dark level.
  // 4 = Press mode button four times to enter. Calibrate motor speeds to drive straight.
  
  switch(ui_Robot_State_Index)
  {
    case 0: //Robot stopped
    {
      Serial.println("nothing...");
      Ping();
   
      servo_LeftMotor.writeMicroseconds(Motor_Stop); 
      servo_RightMotor.writeMicroseconds(Motor_Stop);
      Serial.print(" Ultrasonic 1: ");
      Serial.println(ultrasonic1/58);
      Serial.print(" Ultrasonic 2: ");
      Serial.println(ultrasonic2/58);
      Serial.print(" Ultrasonic 3: ");
      Serial.println(ultrasonic3/58);
      
      ui_Mode_Indicator_Index = 0;
      break;
    } 
  
    case 1:  //Robot Run after 3 seconds
    {
      if (bt_45_S_Time_Up == false)
      {
        if(bt_3_S_Time_Up)
        {
          Ping();
          Serial.print(" Ultrasonic 1: ");
          Serial.println(ultrasonic1/58);
          Serial.print(" Ultrasonic 2: ");
          Serial.println(ultrasonic2/58);
          Serial.print(" Ultrasonic 3: ");
          Serial.println(ultrasonic3/58);
            
          if ( (ultrasonic1/58 > ul_front_D) && (ultrasonic2/58 > 10) && (ultrasonic3/58 > 10) && flag_1 == true) //Case 1: no objects nearby, drive straight 
          {
            if (A == true)
            {
              startTime = millis();
              A = false;
              Serial.print("startTime: ");
              Serial.println(startTime);
            }
            Serial.print('\n');
            Serial.println("case1");
  
            servo_RightMotor.writeMicroseconds(1750);
            servo_LeftMotor.writeMicroseconds(1800); 
          }
          
          else if ( ((ultrasonic1/58) <= ul_front_D && (ultrasonic1/58) > 1)  && ((ultrasonic2/58) <= ul_side_D) && ((ultrasonic2/58) > 1) && ((ultrasonic3/58) <= ul_side_D) && ((ultrasonic3/58) > 1) && flag_2A == true) //Case 2: object in front, AND object on left, AND object on right. back up turn 180deg
          {
            servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
            servo_RightMotor.writeMicroseconds(Motor_Stop);
            Serial.println("case2A");
            flag_1 = false;
            if (A == false)
            {
              endTime = millis();
              Serial.print("endTime: ");
              Serial.println(endTime);
              Movement T;
              T.move = 1;
              T.time = endTime - startTime;
              stack.push(T); 
              A = true;
              Serial.println("saved");
            } 
            flag_2A = false;
            flag_3A = false;
            flag_4A = false;
            flag_5A = false;
            flag_6A = false;
            flag_7A = false;
            flag_8A = false;
          
            flag_2B = true;    
          }
            if (flag_2B == true)
            {
              currentMillis = millis();
              //Serial.print ("Millis: ");
              //Serial.println(currentMillis);
                if(flag_2C == true) // start timer
                {
                  startVal = currentMillis;
                  flag_2C = false;
                }
                if (flag_2C == false)
                {
                    if((currentMillis-startVal) < 700) //back up slightly after .7 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1400);
                      servo_LeftMotor.writeMicroseconds(1400);
                      Serial.println("case2B");
                    }
                    else if((currentMillis-startVal)> 700 && (currentMillis-startVal) < 1800)//turn 180
                    {
                      servo_RightMotor.writeMicroseconds(1700);
                      servo_LeftMotor.writeMicroseconds(1300);
                      Serial.println("case2C");
                    }
                    else if((currentMillis-startVal) > 1800)
                    {
                      flag_1 = true; 
                      flag_2A = true;
                      flag_3A = true;
                      flag_4A = true;
                      flag_5A = true;
                      flag_6A = true;
                      flag_7A = true;
                      flag_8A = true;
  
                      flag_2B = false;
                      flag_2C = true;

                      Movement T;
                      T.move = 2;
                      T.time = 1800;
                      stack.push(T);
                    }
                }
             }
  
   else if ( ((ultrasonic1/58) <= ul_front_D && (ultrasonic1/58) > 1)  && (ultrasonic2/58 > ul_side_D) && (ultrasonic3/58 > ul_side_D) && flag_3A == true) //Case 3: object in front, no object on left, no object on right. back up, turn left (can be right too)
          {
            servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
            servo_RightMotor.writeMicroseconds(Motor_Stop);
            Serial.println("case3A");
            flag_1 = false;
            if (A == false)
            {
              endTime = millis();
              Serial.print("endTime: ");
              Serial.println(endTime);
              Movement T;
              T.move = 1;
              T.time = endTime - startTime;
              stack.push(T); 
              A = true;
              Serial.println("saved");
            } 
            flag_2A = false;
            flag_3A = false;
            flag_4A = false;
            flag_5A = false;
            flag_6A = false;
            flag_7A = false;
            flag_8A = false;
  
            
            flag_3B = true; 
          }
            if (flag_3B == true)
            {
              currentMillis = millis();
              //Serial.print ("Millis: ");
              //Serial.println(currentMillis);
                if(flag_3C == true) // start timer
                {
                  startVal = currentMillis;
                  flag_3C = false;
                }
                if (flag_3C == false)
                {
                    if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1400);
                      servo_LeftMotor.writeMicroseconds(1400);
                      Serial.println("case3B");
                    }
                    else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 2000)//turn left
                    {
                      servo_RightMotor.writeMicroseconds(1700);
                      servo_LeftMotor.writeMicroseconds(1300); 
                      Serial.println("case3C");
                    }
                    else if((currentMillis-startVal) > 2000)
                    {
                      flag_1 = true; 
                      flag_2A = true;
                      
                      flag_3A = true;
                      flag_4A = true;
                      flag_5A = true;
                      flag_6A = true;
                      flag_7A = true;
                      flag_8A = true;
                      
                      flag_3B = false;
                      flag_3C = true;

                      Movement T;
                      T.move = 3;
                      T.time = 2000;
                      stack.push(T);
                    }
                }
             }
             
   else if ( (ultrasonic1/58 > ul_front_D) && (ultrasonic2/58 > ul_side_D) && ((ultrasonic3/58) <= ul_side_D) && ((ultrasonic3/58) > 1) && flag_4A == true) //Case 4: NO object in front, no object on left, AND object on right, turn left 90deg
          {
            servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
            servo_RightMotor.writeMicroseconds(Motor_Stop);
            Serial.println("case4A"); 
            flag_1 = false;
            if (A == false)
            {
              endTime = millis();
              Serial.print("endTime: ");
              Serial.println(endTime);
              Movement T;
              T.move = 1;
              T.time = endTime - startTime;
              stack.push(T); 
              A = true;
              Serial.println("saved");
            }  
            flag_2A = false;
            flag_3A = false;
            flag_4A = false;
            flag_5A = false;
            flag_6A = false;
            flag_7A = false;
            flag_8A = false;
            
            flag_4B = true; 
          }
            if (flag_4B == true)
            {
              currentMillis = millis();
              //Serial.print ("Millis: ");
              //Serial.println(currentMillis);
                if(flag_4C == true) // start timer
                {
                  startVal = currentMillis;
                  flag_4C = false;
                }
                if (flag_4C == false)
                {
                    if((currentMillis-startVal) < 600) //turn left 90deg
                    {
                      servo_RightMotor.writeMicroseconds(1700);
                      servo_LeftMotor.writeMicroseconds(1300);
                      Serial.println("case4B");
                    }
                    else if((currentMillis-startVal) > 600)
                    {
                      flag_1 = true; 
                      flag_2A = true;
                      flag_3A = true;
                      flag_4A = true;
                      flag_5A = true;
                      flag_6A = true;
                      flag_7A = true;
                      flag_8A = true;
                      
                      flag_4B = false;
                      flag_4C = true;

                      Movement T;
                      T.move = 4;
                      T.time = 600;
                      stack.push(T);
                    }
                }
             }
  
   if ( (ultrasonic1/58 > ul_front_D) && ((ultrasonic2/58) <= ul_side_D) && ((ultrasonic2/58) > 1) && (ultrasonic3/58 > ul_side_D) && flag_5A == true) //Case 5: NO object in front, AND object on left, no object on right, turn right 90deg
          {
            servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
            servo_RightMotor.writeMicroseconds(Motor_Stop);
            Serial.println("case5A");
            flag_1 = false;
            if (A == false)
            {
              endTime = millis();
              Serial.print("endTime: ");
              Serial.println(endTime);
              Movement T;
              T.move = 1;
              T.time = endTime - startTime;
              stack.push(T); 
              A = true;
              Serial.println("saved");
            }  
            flag_2A = false;
            flag_3A = false;
            flag_4A = false;
            flag_5A = false;
            flag_6A = false;
            flag_7A = false;
            flag_8A = false;
            
            flag_5B = true; 
          }
            if (flag_5B == true)
            {
              currentMillis = millis();
              //Serial.print ("Millis: ");
              //Serial.print (currentMillis);
              //Serial.print('\n')
                if(flag_5C == true) // start timer
                {
                  startVal = currentMillis;
                  flag_5C = false;
                }
                if (flag_5C == false)
                {
                    if((currentMillis-startVal) < 600) //turn right 90deg
                    {
                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700);
                      Serial.println("case5B");
                    }
                    else if((currentMillis-startVal) > 600)
                    {
                      flag_1 = true; 
                      flag_2A = true;
                      flag_3A = true;
                      flag_4A = true;
                      flag_5A = true;
                      flag_6A = true;
                      flag_7A = true;
                      flag_8A = true;
                      
                      flag_5B = false;
                      flag_5C = true;

                      Movement T;
                      T.move = 5;
                      T.time = 600;
                      stack.push(T);
                    }
                }
             }
  
  else if ( ((ultrasonic1/58) <= ul_front_D && (ultrasonic1/58) > 1)  && ((ultrasonic2/58) <= ul_side_D) && ((ultrasonic2/58) > 1) && ((ultrasonic3/58) > ul_side_D) && flag_6A == true) //Case 6: object in front, AND object on left, no object on right. back up turn right 90deg
          {
            servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
            servo_RightMotor.writeMicroseconds(Motor_Stop);
            Serial.println("case6A");
            flag_1 = false;
            if (A == false)
            {
              endTime = millis();
              Serial.print("endTime: ");
              Serial.println(endTime);
              Movement T;
              T.move = 1;
              T.time = endTime - startTime;
              stack.push(T); 
              A = true;
              Serial.println("saved");
            }  
            flag_2A = false;
            flag_3A = false;
            flag_4A = false;
            flag_5A = false;
            flag_6A = false;
            flag_7A = false;
            flag_8A = false;
            
            flag_6B = true; 
          }
            if (flag_6B == true)
            {
              currentMillis = millis();
              //Serial.print ("Millis: ");
              //Serial.println(currentMillis);
                if(flag_6C == true) // start timer
                {
                  startVal = currentMillis;
                  flag_6C = false;
                }
                if (flag_6C == false)
                {
                    if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1400);
                      servo_LeftMotor.writeMicroseconds(1400);
                      Serial.println("case6B");
                    }
                    else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 900)//turn right
                    {
                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700);
                      Serial.println("case6C");
                    }
                    else if((currentMillis-startVal) > 900)
                    {
                      flag_1 = true; 
                      flag_2A = true;
                      flag_3A = true;
                      flag_4A = true;
                      flag_5A = true;
                      flag_6A = true;
                      flag_7A = true;
                      flag_8A = true;
                      
                      flag_6B = false;
                      flag_6C = true;

                      Movement T;
                      T.move = 6;
                      T.time = 900;
                      stack.push(T);
                    }
                }
             }
  
       else if ( ((ultrasonic1/58) <= ul_front_D && (ultrasonic1/58) > 1)  && ((ultrasonic2/58) <= ul_side_D) && ((ultrasonic2/58) > 1) && ((ultrasonic3/58) > ul_side_D) && flag_7A == true) //Case 7: object in front, AND object on left, no object on right. back up turn right 90deg
          {
            servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
            servo_RightMotor.writeMicroseconds(Motor_Stop);
            Serial.println("case7A");
            flag_1 = false;
            if (A == false)
            {
              endTime = millis();
              Serial.print("endTime: ");
              Serial.println(endTime);
              Movement T;
              T.move = 1;
              T.time = endTime - startTime;
              stack.push(T); 
              A = true;
              Serial.println("saved");
            }  
            flag_2A = false;
            flag_3A = false;
            flag_4A = false;
            flag_5A = false;
            flag_6A = false;
            flag_7A = false;
            flag_8A = false;
            
            flag_7B = true; 
          }
            if (flag_7B == true)
            {
              currentMillis = millis();
              //Serial.print ("Millis: ");
              //Serial.println(currentMillis);
                if(flag_7C == true) // start timer
                {
                  startVal = currentMillis;
                  flag_7C = false;
                }
                if (flag_7C == false)
                {
                    if((currentMillis-startVal) < 400) //back up slightly after .4 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1400);
                      servo_LeftMotor.writeMicroseconds(1400);
                      Serial.println("case7B");
                    }
                    else if((currentMillis-startVal)> 400 && (currentMillis-startVal) < 900)//turn right
                    {
                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700);
                      Serial.println("case7C");
                    }
                    else if((currentMillis-startVal) > 900)
                    {
                      flag_1 = true; 
                      flag_2A = true;
                      flag_3A = true;
                      flag_4A = true;
                      flag_5A = true;
                      flag_6A = true;
                      flag_7A = true;
                      flag_8A = true;
                      
                      flag_7B = false;
                      flag_7C = true;

                      Movement T;
                      T.move = 7;
                      T.time = 900;
                      stack.push(T);
                    }
                }
             }
  
    else if ( ((ultrasonic1/58) > ul_front_D) && ((ultrasonic2/58) <= ul_side_D && (ultrasonic2/58) > 1)  && (((ultrasonic3/58) <= ul_side_D) && (ultrasonic3/58) > 1) && flag_8A == true) //Case 8: no object in front, AND object on left, AND object on right. straight
          {
            Serial.print('\n');
            Serial.println("case8");
  
            servo_RightMotor.writeMicroseconds(1750);
            servo_LeftMotor.writeMicroseconds(1800);
             }
             
             ui_Mode_Indicator_Index = 1;
        }
        break;
      }
           else if (bt_45_S_Time_Up == true) //begin first return home 
      {
        Serial.println("transverse");
        // flag to check if stack is empty: 0 = full, 1 = empty
        bool stack_empty = stack.isEmpty();
        int size = stack.count();
        Serial.print("size: ");
        Serial.println(size);
        Serial.print("stack flag: ");
        Serial.println(stack_empty);
        

          if (B == true && stack_empty == false)
          {
            Serial.println("saving Move");
            Movement lastMove;
            lastMove = stack.pop();
            currentMove = lastMove.move;
            currentTime = lastMove.time;
            Serial.print("currentMove: ");
            Serial.println(currentMove);
            Serial.print("currentTime: ");
            Serial.println(currentTime);
            B = false;
            C = true;  
          }
          if (B == false && stack_empty == false)
          {
            if (currentMove == 1 && B == false)
            {
              Serial.println("Starting to reverse case1");
              newStartTime = millis();
              Serial.print("newStartTime: ");
              Serial.println(newStartTime);
              if (C == true)
              {
                newEndTime = newStartTime + currentTime;
                Serial.print("newEndTime: ");
                Serial.println(newEndTime);
                C = false;
              }
              if ( newStartTime < newEndTime )
              {
                 Serial.print("newStartTime2: ");
                 Serial.println(newStartTime);
                 Serial.print("newEndTime2: ");
                 Serial.println(newEndTime);
                 Serial.println("backing up...");
                 servo_RightMotor.writeMicroseconds(1400);
                 servo_LeftMotor.writeMicroseconds(1400);
               }
               else
               {
                  Serial.println("Stopping1...");
                 servo_RightMotor.writeMicroseconds(1500);
                 servo_LeftMotor.writeMicroseconds(1500);
                 B = true;
               }
            } 
            
            if (currentMove == 3 && B == false)
            { 
              servo_LeftMotor.writeMicroseconds(Motor_Stop); //stop
              servo_RightMotor.writeMicroseconds(Motor_Stop);
              
              flag_3B_reversed = true; 
             if (flag_3B_reversed == true) 
            {
              currentMillis_reversed = millis();
              //Serial.print ("Millis: ");
              //Serial.println(currentMillis);
                if(flag_3C_reversed == true) // start timer
                {
                  Serial.print(" startVal_reversed = ");
                  Serial.println( startVal_reversed);
                  Serial.print(" currentMillis_reversed = ");
                  Serial.println( currentMillis_reversed);
                  
                  startVal_reversed = currentMillis_reversed;
                  flag_3C_reversed = false;
                }
                if (flag_3C_reversed == false) //error we are having with Case 3 reversed is it is not leaving the turnright function. 
                {
                    if((currentMillis_reversed- startVal_reversed) < 1600) //turn right 1.6 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1300);
                      servo_LeftMotor.writeMicroseconds(1700);
                      Serial.println("case3B");
                    }
                    else if((currentMillis_reversed- startVal_reversed)> 1600 && (currentMillis_reversed- startVal_reversed) < 2000)//drive straight .4 seconds
                    {
                      servo_RightMotor.writeMicroseconds(1600);
                      servo_LeftMotor.writeMicroseconds(1600); 
                      Serial.println("case3C");
                    }
                    else if((currentMillis_reversed- startVal_reversed) > 2000)
                    {
                      flag_3B_reversed = false;
                      flag_3C_reversed = true;
                      break;
                    }
                   }
                 }
                } 
//             if (currentMove == 3 && B == false)
//          {
//            
//          }
                
          }
          if (stack_empty == true)
          {
            Serial.println("Stopping2...");
              servo_RightMotor.writeMicroseconds(1500);
              servo_LeftMotor.writeMicroseconds(1500);
          }
      }
    }     
          
      
      
    case 2:
    { 
        servo_ScooperMotor.write(ci_Scooper_Motor_Down);
        delay (2000);
         servo_ScooperMotor.write(ci_Scooper_Motor_Up);
        delay (2000);
        
      ui_Mode_Indicator_Index = 2; 
      break;
    }
    
    case 3:
    {
      ui_Mode_Indicator_Index = 3;
      break;
    }
   
    case 4:    //Calibrate motor straightness after 3 seconds.
    {
      if(bt_3_S_Time_Up)
      {
        if(!bt_Cal_Initialized)
        {
          bt_Cal_Initialized = true;
          encoder_LeftMotor.zero();
          encoder_RightMotor.zero();
          ul_Calibration_Time = millis();
          servo_LeftMotor.writeMicroseconds(Motor_Stop); 
          servo_RightMotor.writeMicroseconds(Motor_Stop); 
          
          servo_LeftMotor.writeMicroseconds(ui_Motors_Speed+100);
          servo_RightMotor.writeMicroseconds(ui_Motors_Speed-40);
        }
        else if((millis() - ul_Calibration_Time) > ci_Motor_Calibration_Time) 
        {
          servo_LeftMotor.writeMicroseconds(Motor_Stop); 
          servo_RightMotor.writeMicroseconds(Motor_Stop); 
          Left_Motor_Position = encoder_LeftMotor.getRawPosition();
          Right_Motor_Position = encoder_RightMotor.getRawPosition();
          if(Left_Motor_Position > Right_Motor_Position)
          {
           // May have to update this if different calibration time is used
            ui_Right_Motor_Offset = 0;
            ui_Left_Motor_Offset = (Left_Motor_Position - Right_Motor_Position) / 4;  
          }
          else
          {
           // May have to update this if different calibration time is used
            ui_Right_Motor_Offset = (Right_Motor_Position - Left_Motor_Position) / 4;
            ui_Left_Motor_Offset = 0;
          }
          
#ifdef DEBUG_MOTOR_CALIBRATION
          Serial.print("Motor Offsets: Left = ");
          Serial.print(ui_Left_Motor_Offset);
          Serial.print(", Right = ");
          Serial.println(ui_Right_Motor_Offset);
#endif              
          EEPROM.write(ci_Right_Motor_Offset_Address_L, lowByte(ui_Right_Motor_Offset));
          EEPROM.write(ci_Right_Motor_Offset_Address_H, highByte(ui_Right_Motor_Offset));
          EEPROM.write(ci_Left_Motor_Offset_Address_L, lowByte(ui_Left_Motor_Offset));
          EEPROM.write(ci_Left_Motor_Offset_Address_H, highByte(ui_Left_Motor_Offset));
          
          ui_Robot_State_Index = 0;    // go back to Mode 0 
        }
#ifdef DEBUG_MOTOR_CALIBRATION           
          Serial.print("Encoders L: ");
          Serial.print(encoder_LeftMotor.getRawPosition());
          Serial.print(", R: ");
          Serial.println(encoder_RightMotor.getRawPosition());
#endif        
        ui_Mode_Indicator_Index = 4;
      } 
      break;
    }    
  }

  if((millis() - ul_Display_Time) > ci_Display_Time)
  {
    ul_Display_Time = millis();

#ifdef DEBUG_MODE_DISPLAY  
    Serial.print("Mode: ");
    Serial.println(ui_Mode_Indicator[ui_Mode_Indicator_Index], DEC);
#endif
    bt_Heartbeat = !bt_Heartbeat;
    CharliePlexM::Write(ci_Heartbeat_LED, bt_Heartbeat);
    digitalWrite(13, bt_Heartbeat);
    Indicator();
  }
} 

// set mode indicator LED state
void Indicator()
{
  //display routine, if true turn on led
  CharliePlexM::Write(ci_Indicator_LED,!(ui_Mode_Indicator[ui_Mode_Indicator_Index] & 
                      (iArray[iArrayIndex])));
  iArrayIndex++;
  iArrayIndex = iArrayIndex & 15;
}


// measure distance to target using ultrasonic sensor  
void Ping()
{
  //Send the Ultrasonic Range Finder a 10 microsecond pulse per tech spec
  digitalWrite(Ultrasonic_Ping1, HIGH);
  delayMicroseconds(10);  //The 10 microsecond pause where the pulse in "high"
  digitalWrite(Ultrasonic_Ping1, LOW);
  //use command pulseIn to listen to Ultrasonic_Data pin to record the
  //time that it takes from when the Pin goes HIGH until it goes LOW 
  ultrasonic1 = pulseIn(Ultrasonic_Data1, HIGH, 10000);

  //Send the Ultrasonic Range Finder a 10 microsecond pulse per tech spec
  digitalWrite(Ultrasonic_Ping2, HIGH);
  delayMicroseconds(10);  //The 10 microsecond pause where the pulse in "high"
  digitalWrite(Ultrasonic_Ping2, LOW);
  //use command pulseIn to listen to Ultrasonic_Data pin to record the
  //time that it takes from when the Pin goes HIGH until it goes LOW 
  ultrasonic2 = pulseIn(Ultrasonic_Data2, HIGH, 10000);

  //Send the Ultrasonic Range Finder a 10 microsecond pulse per tech spec
  digitalWrite(Ultrasonic_Ping3, HIGH);
  delayMicroseconds(10);  //The 10 microsecond pause where the pulse in "high"
  digitalWrite(Ultrasonic_Ping3, LOW);
  //use command pulseIn to listen to Ultrasonic_Data pin to record the
  //time that it takes from when the Pin goes HIGH until it goes LOW 
  ultrasonic3 = pulseIn(Ultrasonic_Data3, HIGH, 10000);
}
